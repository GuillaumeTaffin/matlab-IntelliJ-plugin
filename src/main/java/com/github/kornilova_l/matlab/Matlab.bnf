{
  parserClass="com.github.kornilova_l.matlab.MatlabParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Matlab"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.kornilova_l.matlab.psi"
  psiImplPackage="com.github.kornilova_l.matlab.psi.impl"

  elementTypeHolderClass="com.github.kornilova_l.matlab.psi.MatlabTypes"
  elementTypeClass="com.github.kornilova_l.matlab.psi.MatlabElementType"
  tokenTypeClass="com.github.kornilova_l.matlab.psi.MatlabTokenType"

  tokens=[
      space='regexp:\s+'
      comment='regexp://.*'
      id='regexp:[A-z]+[A-z0-9_]*'
      string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

      integer='regexp:[0-9]+'
      newline = "regexp:\n"
  ]

  extends(".*expr")=expr
}

root ::= element *
private element ::= expr ";"?

// left recursion and empty PSI children define expression root
expr ::= assign_expr
  | primary_group
  | unary_group


private unary_group ::= unary_min_expr | unary_not_expr
private primary_group ::= literal_expr | simple_ref_expr

// expressions: auto-operator detection or parents
//fake ref_expr ::= expr?
literal_expr ::= number | string
simple_ref_expr ::= id // {extends=ref_expr elementType=ref_expr}
unary_min_expr ::= '-' expr
unary_not_expr ::= '!' expr
assign_expr ::= expr '=' expr { rightAssociative=true }


float_literal ::=
        (integer "." integer exponent_part)
        | ("." integer [ exponent_part ])
        | (integer exponent_part)
        | (integer "." exponent_part)

number ::= float_literal | integer [ "i" | "j" ]

exponent_part ::= ("e" ["+" | "-"] integer) | ("e" integer)