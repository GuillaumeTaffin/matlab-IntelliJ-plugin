{
  parserClass="com.github.kornilova_l.matlab.MatlabParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Matlab"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.kornilova_l.matlab.psi"
  psiImplPackage="com.github.kornilova_l.matlab.psi.impl"

  elementTypeHolderClass="com.github.kornilova_l.matlab.psi.MatlabTypes"
  elementTypeClass="com.github.kornilova_l.matlab.psi.MatlabElementType"
  tokenTypeClass="com.github.kornilova_l.matlab.psi.MatlabTokenType"

  tokens=[
      space='regexp:\s+'
      comment='regexp://.*'
      id='regexp:\p{Alpha}\w*'
      string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

      syntax='regexp:;|\.|\+|-|\*\*|\*|==|=|/|,|\(|\)|\^|\!=|\!|>=|<=|>|<'
      integer='regexp:[0-9]+'
      newline='\n'
  ]

  extends(".*expr")=expr
}

root ::= element *
private element ::= expr ";"?  {recoverWhile=element_recover}
private element_recover ::= !('(' | '+' | '-' | '!' | '*' | id | float_literal | integer)

// left recursion and empty PSI children define expression root
expr ::= assign_expr
  | conditional_group
  | add_group
  | mul_group
  | unary_group
  | exp_expr
  | call_expr
  | qualification_expr
  | primary_group


private conditional_group ::= elvis_expr | conditional_expr
private unary_group ::= unary_min_expr | unary_not_expr
private mul_group ::= mul_expr | div_expr
private add_group ::= plus_expr | minus_expr
private primary_group ::= special_expr | simple_ref_expr | literal_expr | paren_expr

// expressions: auto-operator detection or parents
fake ref_expr ::= expr? '.' identifier
simple_ref_expr ::= identifier {extends=ref_expr elementType=ref_expr}
qualification_expr ::= expr '.' identifier {extends=ref_expr elementType=ref_expr}
call_expr ::= ref_expr arg_list
arg_list ::= '(' [ !')' expr  (',' expr) * ] ')' {pin(".*")=1}
literal_expr ::= number | string
identifier ::= id
unary_min_expr ::= '-' expr
unary_not_expr ::= '!' expr
assign_expr ::= expr '=' expr { rightAssociative=true }
conditional_expr ::= expr ('<' | '>' | '<=' | '>=' | '==' | '!=') expr
div_expr ::= expr '/' expr
mul_expr ::= expr '*' expr
minus_expr ::= expr '-' expr
plus_expr ::= expr '+' expr
exp_expr ::= expr ('**' expr) + // N-ary variant
paren_expr ::= '(' expr ')'
elvis_expr ::= expr '?' expr ':' expr

// test specific expressions
external special_expr ::= meta_special_expr
meta_special_expr ::= '*' '(' simple_ref_expr ',' mul_expr ')' {elementType="special_expr" pin=2}

float_literal ::=
        integer "." integer [ exponent_part ]
        | "." integer [ exponent_part ]
        | integer exponent_part
        | integer "." exponent_part

number ::= float_literal | integer [ "i" | "j" ]

exponent_part ::= "e" [ "+" | "-" | "" ] integer